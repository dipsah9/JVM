Class Loading, Linking, and Initialization in JVM
Class loading in JVM is the process of loading .class files (compiled Java bytecode) into the memory to 
be executed by the JVM. This is performed by the Class Loader Subsystem, which plays a crucial role in 
dynamic class loading. The whole process can be divided into several stages: Loading, Linking, and 
Initialization. Reading .class file data and store corresponding binary data in method area. 


1) Loading
Loading is the process where the .class file is read and its binary data is brought into memory. 
The ClassLoader subsystem is responsible for this. When a class is referenced for the first time, 
the JVM looks for its .class file and loads it into the method area of the JVM memory.

During loading:

The fully qualified name of the class (e.g., Test in Test.class) is verified.
The class file is located, loaded, and its binary representation is stored.
JVM allocates memory to store the metadata related to the class, like the constant pool, methods, and fields.
Types of Class Loaders:

Bootstrap ClassLoader: Loads core Java classes (rt.jar), implemented in native languages like C/C++.

Extension ClassLoader: Loads classes from the extension directory (lib/ext), implemented in Java.

Application ClassLoader: Loads classes defined in the application classpath, also implemented in Java.

After the class is loaded into memory, it goes through Linking and Initialization phases.

2) Linking
Linking consists of three activities: Verification, Preparation, and Resolution.

a) Verification:
Bytecode Verifier: Responsible for verifying the correctness of the bytecode in the .class file. If 
the bytecode does not conform to JVM specifications, it will throw a java.lang.VerifyError.
The verifier ensures the structural correctness of the class file (e.g., proper stack usage, correct
method signatures). This step improves the security and stability of the Java application by ensuring that 
no invalid bytecode is executed. Responsible Entity: Bytecode Verifier (a part of the class loader subsystem).
If verification fails, a java.lang.VerifyError will be thrown at runtime.

b) Preparation:
In this stage, the JVM allocates memory for all static variables of the class and assigns default values (e.g., 0 for integers, null for object references).
This is purely about memory allocation; actual initialization of variables (i.e., setting their original values) happens in the Initialization phase.
c) Resolution:
This phase replaces all symbolic references in the class with direct references to memory locations in the method area.

Example: In the code snippet below:

class Test {
    public static void main(String[] args) {
        String s = new String("Deep");
        Student s1 = new Student();
    }
}
During resolution, the class loader replaces symbolic names like String, Student, Object, and Test with actual memory references to these classes.

Every symbol is stored in the constant pool of the class. During resolution, symbolic names (like Test, String, etc.) are replaced with actual memory addresses.

3) Initialization
In the initialization phase, the JVM assigns original values to static variables and executes any static blocks in the class.
Static variables are initialized with actual values (after default values were assigned in the Preparation phase).
Initialization happens in the following order:
Parent classes are initialized before child classes.
Static blocks and static variables are executed from top to bottom in the order they appear.
If any error occurs during Loading, Linking, or Initialization, a java.lang.LinkageError is thrown at runtime.

Types of Class Loaders
Bootstrap ClassLoader (Primordial ClassLoader):

Responsible for loading core Java classes located in the rt.jar file (Java runtime classes).
The boot class path (jdk -> jre -> lib -> rt.jar) is used by the Bootstrap ClassLoader.
It is implemented in native languages like C/C++ and is by default available with every JVM.
Extension ClassLoader:

Child class of the Bootstrap ClassLoader.
Responsible for loading classes from the Extension class path (jdk -> jre -> lib -> ext).
It is implemented in Java, and the corresponding .class file is sun.misc.Launcher$ExtClassLoader.class.
Application ClassLoader (System ClassLoader):

Child class of the Extension ClassLoader.
Loads classes from the Application class path (the classpath set by the user).
It is implemented in Java, and the corresponding .class file is sun.misc.Launcher$AppClassLoader.class.
NOTE:
These phases—Loading, Linking, and Initialization—are crucial parts of the Class Loader Subsystem. 
Any errors in these stages will result in runtime exceptions such as java.lang.VerifyError during verification and java.lang.LinkageError during loading, linking, or initialization.


ClassLoader Delegation Hierarchy Principle

Whenever the JVM encounters a particular class, it first checks whether the corresponding .class file is already loaded in the method area. If it is loaded, the JVM uses the existing class. 
If not, the JVM requests the ClassLoader subsystem to load the class.

Delegation Process:

The ClassLoader subsystem hands over the request to the Application ClassLoader (AppClassLoader).
The AppClassLoader delegates the request to the Extension ClassLoader (ExtClassLoader), which, in turn, delegates it to the Bootstrap ClassLoader.
Loading Mechanism:

Bootstrap ClassLoader: Searches in the bootstrap class path (typically rt.jar). If the class is found, it is loaded here. If not, it delegates the request to the ExtClassLoader.
Extension ClassLoader: Searches in the extension class path (typically lib/ext). If found, it loads the class; otherwise, it delegates to the AppClassLoader.
Application ClassLoader: Searches in the application class path (defined by the CLASSPATH environment variable). If found, it loads the class; if not, a runtime exception occurs 
(e.g., NoClassDefFoundError or ClassNotFoundException).

Example:

class Test {
    public static void main(String[] args) {
        System.out.println("ClassLoader for String: " + String.class.getClassLoader());  // null (Bootstrap ClassLoader)
        System.out.println("ClassLoader for Test: " + Test.class.getClassLoader());      // AppClassLoader
        System.out.println("ClassLoader for Customer: " + Customer.class.getClassLoader()); // Assuming Customer class exists
    }
}

Bootstrap ClassLoader is not a Java object, hence it returns null.
Extension and Application ClassLoaders are Java objects, so you get their corresponding output.
ClassLoader follows a priority hierarchy: Bootstrap ClassLoader > Extension ClassLoader > Application ClassLoader.

Heap Memory
For every JVM, a heap area is available, created at JVM startup. Objects and their instance variables are stored in this heap. Arrays, being objects in Java, are also stored in the heap. 
Heap memory is accessible by multiple threads, and data stored here is not thread-safe. The memory layout need not be contiguous.

class HeapDemo {
    public static void main(String[] args) {
        Runtime r = Runtime.getRuntime();
        System.out.println("Max Memory: " + r.maxMemory());
        System.out.println("Total Memory: " + r.totalMemory());
        System.out.println("Free Memory: " + r.freeMemory());
        System.out.println("Consumed Memory: " + (r.totalMemory() - r.freeMemory()));
    }
}

Max Memory: Total memory JVM can allocate.
Total Memory: Total memory allocated to the heap.
Free Memory: Unused memory in the heap.
To adjust heap size:

Set Max Heap: java -Xmx<size>m ClassName
Set Min Heap: java -Xms<size>m ClassName

Interpreter vs JIT Compiler
The interpreter reads bytecode, converts it to machine code, and executes it line by line. The downside is repeated interpretation, which reduces performance. To solve this, the JIT (Just-In-Time) Compiler is introduced.

JIT Compiler:
Improves performance by compiling frequently used methods.
Maintains a count for method calls. If a method reaches a threshold, JIT compiles it into native code.
After compilation, the native code is executed directly on future calls, improving performance.
The threshold varies between JVMs.
Advanced JIT compilers can recompile methods for better optimization.
Note: The JVM interprets the entire program at least once. JIT is only for frequently invoked methods.

JNI (Java Native Interface)
JNI serves as a bridge between Java methods and native libraries. It provides the JVM with information about native libraries and handles communication with them.

Class File Format
Magic Number: The first four bytes of the class file, used to verify that the file is generated by a valid compiler. The value is 0xcafebabe. If missing, a java.lang.ClassFormatError is thrown.

Versioning: Represented as major.minor. A lower-version JVM can run a higher-version compiled .class file, but not vice-versa. Trying to do so results in UnsupportedClassVersionError.

Constant Pool Count: Represents the constants in the constant pool.

Access Flags: Information about class modifiers (e.g., public, abstract).

this_class: Fully qualified name of the current class.

super_class: Fully qualified name of the immediate superclass.

interface_count: Number of interfaces implemented by the current class.

fields_count: Number of fields in the current class.

method_count: Number of methods in the current class.
