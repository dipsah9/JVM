Class Loading, Linking, and Initialization in JVM
Class loading in JVM is the process of loading .class files (compiled Java bytecode) into the memory to 
be executed by the JVM. This is performed by the Class Loader Subsystem, which plays a crucial role in 
dynamic class loading. The whole process can be divided into several stages: Loading, Linking, and 
Initialization.

1) Loading
Loading is the process where the .class file is read and its binary data is brought into memory. 
The ClassLoader subsystem is responsible for this. When a class is referenced for the first time, 
the JVM looks for its .class file and loads it into the method area of the JVM memory.

During loading:

The fully qualified name of the class (e.g., Test in Test.class) is verified.
The class file is located, loaded, and its binary representation is stored.
JVM allocates memory to store the metadata related to the class, like the constant pool, methods, and fields.
Types of Class Loaders:

Bootstrap ClassLoader: Loads core Java classes (rt.jar), implemented in native languages like C/C++.
Extension ClassLoader: Loads classes from the extension directory (lib/ext), implemented in Java.
Application ClassLoader: Loads classes defined in the application classpath, also implemented in Java.
After the class is loaded into memory, it goes through Linking and Initialization phases.

2) Linking
Linking consists of three activities: Verification, Preparation, and Resolution.

a) Verification:
Bytecode Verifier: Responsible for verifying the correctness of the bytecode in the .class file. If 
the bytecode does not conform to JVM specifications, it will throw a java.lang.VerifyError.
The verifier ensures the structural correctness of the class file (e.g., proper stack usage, correct
method signatures). This step improves the security and stability of the Java application by ensuring that 
no invalid bytecode is executed. Responsible Entity: Bytecode Verifier (a part of the class loader subsystem).
If verification fails, a java.lang.VerifyError will be thrown at runtime.

b) Preparation:
In this stage, the JVM allocates memory for all static variables of the class and assigns default values (e.g., 0 for integers, null for object references).
This is purely about memory allocation; actual initialization of variables (i.e., setting their original values) happens in the Initialization phase.
c) Resolution:
This phase replaces all symbolic references in the class with direct references to memory locations in the method area.

Example: In the code snippet below:

java
Code kopieren
class Test {
    public static void main(String[] args) {
        String s = new String("Deep");
        Student s1 = new Student();
    }
}
During resolution, the class loader replaces symbolic names like String, Student, Object, and Test with actual memory references to these classes.

Every symbol is stored in the constant pool of the class. During resolution, symbolic names (like Test, String, etc.) are replaced with actual memory addresses.

3) Initialization
In the initialization phase, the JVM assigns original values to static variables and executes any static blocks in the class.
Static variables are initialized with actual values (after default values were assigned in the Preparation phase).
Initialization happens in the following order:
Parent classes are initialized before child classes.
Static blocks and static variables are executed from top to bottom in the order they appear.
If any error occurs during Loading, Linking, or Initialization, a java.lang.LinkageError is thrown at runtime.

Types of Class Loaders
Bootstrap ClassLoader (Primordial ClassLoader):

Responsible for loading core Java classes located in the rt.jar file (Java runtime classes).
The boot class path (jdk -> jre -> lib -> rt.jar) is used by the Bootstrap ClassLoader.
It is implemented in native languages like C/C++ and is by default available with every JVM.
Extension ClassLoader:

Child class of the Bootstrap ClassLoader.
Responsible for loading classes from the Extension class path (jdk -> jre -> lib -> ext).
It is implemented in Java, and the corresponding .class file is sun.misc.Launcher$ExtClassLoader.class.
Application ClassLoader (System ClassLoader):

Child class of the Extension ClassLoader.
Loads classes from the Application class path (the classpath set by the user).
It is implemented in Java, and the corresponding .class file is sun.misc.Launcher$AppClassLoader.class.
NOTE:
These phases—Loading, Linking, and Initialization—are crucial parts of the Class Loader Subsystem. 
Any errors in these stages will result in runtime exceptions such as java.lang.VerifyError during verification and java.lang.LinkageError during loading, linking, or initialization.